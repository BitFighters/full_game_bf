/* eslint no-unused-vars: 0 */
/* eslint camelcase: 0 */

import {
  table,
  attribute,
  autoGeneratedHashKey,
  rangeKey,
  hashKey,
} from "@aws/dynamodb-data-mapper-annotations";
import { makeTableName } from "@services/utils";
import { DB_CONFIG } from "@config/db_config";
import GlobalSecondaryIndex from "./global";
import { PerIndexOptions, QueryOptions, SecondaryIndexOptions } from "@aws/dynamodb-data-mapper";
import { mapper } from "@services/db/connection";
import { v4 as uuidv4 } from "uuid";
import {
  between, ConditionExpression,
} from "@aws/dynamodb-expressions";
import { FightStates } from "@utils/bitfighter_nft_specs";

@table(makeTableName(DB_CONFIG.TABLES.FIGHTS_DB))
export default class FightsDB extends GlobalSecondaryIndex {
  @autoGeneratedHashKey()
  fight_id: string;
  
  @attribute({ 
    defaultProvider: () => "",
    indexKeyConfigurations: {
      player1_created_index: "HASH",
    },
  })
  player1: string;

  @attribute({ 
    defaultProvider: () => "",
    indexKeyConfigurations: {
      player2_created_index: "HASH",
    },
  })
  player2: string;

  @attribute({ defaultProvider: () => 0 })
  player1_end_health: number;

  @attribute({ defaultProvider: () => 0 })
  player2_end_health: number;

  @attribute()
  p1_minted_id: string;

  @attribute()
  p2_minted_id: string;


  @attribute({ defaultProvider: () => 0 })
  total_bet: number;

  @attribute({ defaultProvider: () => 0 })
  total_bet_p1: number;

  @attribute({ defaultProvider: () => 0 })
  self_bet_p1: number;

  @attribute({ defaultProvider: () => 0 })
  win_pot_p1: number;

  @attribute({ defaultProvider: () => 0 })
  total_tip_p1: number;

  @attribute({ defaultProvider: () => 0 })
  total_tip_p2: number;

  @attribute({ defaultProvider: () => 0 })
  win_pot_p2: number;

  @attribute({ defaultProvider: () => 0 })
  total_bet_p2: number;

  @attribute({ defaultProvider: () => 0 })
  self_bet_p2: number;

  @attribute({ defaultProvider: () => 1 })
  player_count: number;

  @attribute({ defaultProvider: () => 0 })
  total_rough_bet_p1: number;

  @attribute({ defaultProvider: () => 0 })
  total_rough_bet_p2: number;


  @attribute({ 
    defaultProvider: () => new Date().getTime(),
    indexKeyConfigurations: {
      player1_created_index: "RANGE",
      player2_created_index: "RANGE",
      created_at_index: "HASH"
    },
  })
  created_at: number;

  @attribute({ defaultProvider: () => new Date().getTime() })
  updated_at: number;

  @attribute({ defaultProvider: () => FightStates.STALE })
  fight_state: FightStates;

  public static global_secondary_indices = {

    player1_created_index: {
      writeCapacityUnits: 2,
      readCapacityUnits: 2,
      type: "global",
      projection: "all",
    } as SecondaryIndexOptions,

    player2_created_index: {
      writeCapacityUnits: 2,
      readCapacityUnits: 2,
      type: "global",
      projection: "all",
    } as SecondaryIndexOptions,

    created_at_index: {
      writeCapacityUnits: 2,
      readCapacityUnits: 2,
      type: "global",
      projection: "all",
    } as SecondaryIndexOptions,


  } as PerIndexOptions;


  public static async getFightEntry(
    uid: string,
  ) {
    try {
      const result = await mapper.get(
        Object.assign(new FightsDB(), {
          fight_id: uid
        })
      );
      return result;
    } catch (err) {
      throw err;
    }
  }

  public static async getFightEntriesForPlayer(
    player_wallet_address: string,
  ) {

    const queryOptions1: QueryOptions = {
      indexName: "player1_created_index",
      scanIndexForward: false,
    };

    const queryOptions2: QueryOptions = {
      indexName: "player2_created_index",
      scanIndexForward: false,
    };

    const keyConditions: ConditionExpression = {
      type: "And",
      conditions: [
        {
          subject: "created_at",
          type: "Between",
          lowerBound: new Date().getTime() - 1000 * 60 * 60,
          upperBound: new Date().getTime(),
        },
        {
          subject: "player1",
          type: "Equals",
          object: player_wallet_address,
        },
      ],
    };

    const keyConditions2: ConditionExpression = {
      type: "And",
      conditions: [
        {
          subject: "created_at",
          type: "Between",
          lowerBound: new Date().getTime() - 1000 * 60 * 60,
          upperBound: new Date().getTime(),
        },
        {
          subject: "player2",
          type: "Equals",
          object: player_wallet_address,
        },
      ],
    };

    let fight_entries_player = [];
    try {
      const iterator = mapper.query(FightsDB, keyConditions, queryOptions1 );
      for await (const record of iterator) {
        if (record.player1 === player_wallet_address) {
          fight_entries_player.push(record)
        }
      }

      const iterator2 = mapper.query(FightsDB, keyConditions2, queryOptions2 );
      for await (const record of iterator2) {
        if (record.player1 === player_wallet_address) {
          fight_entries_player.push(record)
        }
      }

      return fight_entries_player;
    } catch (err) {
      throw err;
    }
  }

  public static async createFightEntryForUser(
    user_wallet_address: string,
  ) {
    try {
      const result = await mapper.put(
        Object.assign(new FightsDB(), {
          player1: user_wallet_address,
          player2: `dummy_${user_wallet_address}`,
        })
      );
      return result;
    } catch (err) {
      throw err;
    }
  }

  public static async createFightEntryForUserV2(
    p1_address: string,
    p2_address: string
  ) {
    try {
      const result = await mapper.put(
        Object.assign(new FightsDB(), {
          player1: p1_address,
          player2: p2_address,
        })
      );
      return result;
    } catch (err) {
      throw err;
    }
  }
}
